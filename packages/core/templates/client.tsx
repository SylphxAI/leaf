import { createEffect, onCleanup, For } from "solid-js";
import { render } from "solid-js/web";
import { Router, Route, useLocation } from "@solidjs/router";
import { Layout } from "@sylphx/leaf-theme-default";
import "@sylphx/leaf-theme-default/style.css";

// @ts-expect-error - Generated by Vite plugin
import { routes } from "virtual:leaf/routes";
// @ts-expect-error - Generated by Vite plugin
import config from "virtual:leaf/config";

interface LeafRouteConfig {
	path: string;
	component: any;
	toc: any[];
	docFooter: any;
	data?: any;
}

// Convert routes to SolidJS router format
const solidRoutes: LeafRouteConfig[] = routes.map((route: any) => ({
	path: route.path === "/" ? "/" : route.path,
	component: route.component,
	toc: route.toc || [],
	docFooter: route.docFooter,
	data: route.data,
}));

const rootElement = document.getElementById("root");

if (!rootElement) {
	throw new Error("Root element not found");
}

// Wrapper component that uses useLocation
function RouteWrapper(props: { route: LeafRouteConfig }) {
	const location = useLocation();

	// Update document title based on current route
	createEffect(() => {
		const pageTitle = props.route.data?.frontmatter?.title;
		const siteTitle = config?.title || "Leaf";
		document.title = pageTitle ? `${pageTitle} | ${siteTitle}` : siteTitle;
	});

	// Handle scroll restoration on route change
	createEffect(() => {
		const hash = location.hash;
		if (hash) {
			requestAnimationFrame(() => {
				setTimeout(() => {
					const element = document.querySelector(hash);
					if (element) {
						element.scrollIntoView({ behavior: 'smooth' });
					}
				}, 100);
			});
		} else {
			window.scrollTo(0, 0);
		}
	});

	// Handle same-page hash navigation
	createEffect(() => {
		const handleHashChange = () => {
			const hash = window.location.hash;
			if (hash) {
				requestAnimationFrame(() => {
					const element = document.querySelector(hash);
					if (element) {
						element.scrollIntoView({ behavior: 'smooth' });
					}
				});
			}
		};

		window.addEventListener('hashchange', handleHashChange);
		onCleanup(() => window.removeEventListener('hashchange', handleHashChange));
	});

	const RouteComponent = props.route.component;

	return (
		<Layout
			config={config}
			currentRoute={{
				path: location.pathname,
				toc: props.route.toc,
				docFooter: props.route.docFooter,
				frontmatter: props.route.data?.frontmatter || {},
			}}
		>
			<RouteComponent />
		</Layout>
	);
}

render(() => (
	<Router>
		<For each={solidRoutes}>
			{(route) => (
				<Route path={route.path} component={() => <RouteWrapper route={route} />} />
			)}
		</For>
		<Route path="*" component={() => (
			<Layout config={config} currentRoute={null}>
				<div class="prose prose-slate dark:prose-invert max-w-none">
					<h1>404 - Page Not Found</h1>
					<p>The page you're looking for doesn't exist.</p>
				</div>
			</Layout>
		)} />
	</Router>
), rootElement);
